<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA IV Radio</title>
     <link rel="icon" type="image/x-icon" href="icons/radio.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            /* Black background */
            color: #e2e8f0;
            /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden;
            /* Prevent body scroll if content slightly overflows */
        }

        .radio-container {
            background-color: #333333;
            /* Dark Grey background */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            /* Ensures it takes full width on small screens */
            text-align: center;
            border: 2px solid #4a5568;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-left: 15px;
            padding-right: 15px;
            margin-top: 50px;
            /* Added margin to push the container down */
        }

        .icon-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
            /* Default gap */

            /* Responsive gap for smaller screens */
            @media (max-width: 480px) {
                gap: 5px;
                /* Smaller gap on very small screens */
            }
        }

        .station-icon-base {
            /* Base styles for all icons */
            /* Removed border-radius: 50%; to make icons square/rectangular */
            object-fit: contain;
            /* Ensures the entire image fits within the container without cropping */
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
            flex-shrink: 0;
            /* Prevent icons from shrinking below their content size */
        }

        .station-icon-outer-faded {
            /* Responsive width using clamp: min-size, preferred-size (vw), max-size */
            width: clamp(40px, 15vw, 80px);
            /* Increased max size and preferred vw */
            height: clamp(40px, 15vw, 80px);
            /* Increased max size and preferred vw */
            /* Removed border: 1px solid #4a5568; */
            opacity: 0.15;
        }

        .station-icon-faded {
            width: clamp(60px, 20vw, 100px);
            /* Increased max size and preferred vw */
            height: clamp(60px, 20vw, 100px);
            /* Increased max size and preferred vw */
            /* Removed border: 2px solid #4a5568; */
            opacity: 0.4;
        }

        .station-icon {
            width: clamp(80px, 30vw, 160px);
            /* Increased max size and preferred vw */
            height: clamp(80px, 30vw, 160px);
            /* Increased max size and preferred vw */
            /* Removed border: 3px solid #4299e1; */
            /* Removed box-shadow: 0 0 15px rgba(255, 255, 255, 0.6); */
            opacity: 1;
        }

        .station-icon:hover {
            transform: scale(1.05);
        }

        .station-name-display {
            /* Responsive font size using clamp */
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            /* Adjusted font size */
            font-weight: 800;
            color: #4299e1;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(66, 153, 225, 0.5);
            /* Ensure text doesn't overflow */
            white-space: nowrap;
            /* Prevent wrapping */
            overflow: hidden;
            /* Hide overflow */
            text-overflow: ellipsis;
            /* Add ellipsis for overflowed text */
            max-width: 100%;
            /* Allow full width, let ellipsis handle overflow */
        }

        .radio-controls {
            /* New class for the button container */
            display: flex;
            /* Ensure flexbox is applied */
            align-items: center;
            justify-content: center;
            width: 100%;
            gap: 1rem;
            /* Default gap */
        }

        @media (max-width: 640px) {
            /* For small screens (Tailwind's sm breakpoint) */
            .radio-controls {
                gap: 0.75rem;
                /* Reduce gap to 12px */
            }
        }

        @media (max-width: 480px) {
            /* For extra small screens */
            .radio-controls {
                gap: 0.5rem;
                /* Reduce gap further to 8px */
            }
        }

        .control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            /* Removed fixed width, now using flex properties */
            flex-grow: 1;
            /* Allows button to grow to fill space */
            flex-shrink: 1;
            /* Allows button to shrink */
            min-width: 48px;
            /* Minimum width for smaller screens */
            max-width: 80px;
            /* Maximum width to prevent them from becoming too large */
            height: 50px;
            padding: 0;
        }

        .control-button:hover {
            background-color: #636b77;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
        }

        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Specific styling for the play/pause button to be slightly larger */
        #play-pause-button {
            /* Removed fixed width, now using flex properties */
            min-width: 60px;
            /* Slightly larger minimum width */
            max-width: 100px;
            /* Slightly larger maximum width */
        }

        /* Hidden elements */
        .hidden {
            display: none !important;
        }

        /* Toast styles */
        .toast-message {
            position: fixed;
            /* Changed to fixed position relative to viewport */
            top: 150px;
            /* Increased top value for more clearance */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1000;
            white-space: nowrap;
        }

        .toast-message.show {
            opacity: 1;
            visibility: visible;
        }

        .play-icon,
        .pause-icon,
        .prev-icon,
        .next-icon {
            fill: white;
            width: 24px;
            height: 24px;
        }
    </style>
</head>

<body class="antialiased">
    <div class="radio-container">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">GTA IV Radio</h1>

        <div class="icon-carousel">
            <img id="prev-prev-station-icon" src="" alt="Previous Previous Station Icon"
                class="station-icon-outer-faded station-icon-base">
            <img id="prev-station-icon" src="" alt="Previous Station Icon" class="station-icon-faded station-icon-base">
            <img id="current-station-icon" src="" alt="Current Station Icon" class="station-icon station-icon-base">
            <img id="next-station-icon" src="" alt="Next Station Icon" class="station-icon-faded station-icon-base">
            <img id="next-next-station-icon" src="" alt="Next Next Station Icon"
                class="station-icon-outer-faded station-icon-base">
        </div>

        <div class="mb-6">
            <p class="text-lg font-semibold mb-2">Now Playing:</p>
            <p id="current-station-name" class="station-name-display">Select a Station</p>
        </div>

        <audio id="radio-audio" class="w-full mb-6 hidden" controls></audio>

        <div class="flex items-center justify-center w-full radio-controls">
            <button id="prev-button" class="control-button">
                <svg class="prev-icon" viewBox="0 0 24 24">
                    <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" />
                </svg>
            </button>
            <button id="play-pause-button" class="control-button">
                <svg id="play-icon" class="play-icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <svg id="pause-icon" class="pause-icon hidden" viewBox="0 0 24 24">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                </svg>
            </button>
            <button id="next-button" class="control-button">
                <svg class="next-icon" viewBox="0 0 24 24">
                    <path d="M8.59 16.59L13.17 12l-4.58-4.59L10 6l6 6-6 6z" />
                </svg>
            </button>
        </div>

        <div id="toast-message" class="toast-message"></div>

    </div>

    <script>

        const radioStations = [
            { name: 'The Beat 102.7', src: 'https://youtu.be/7-XncPlc67s?si=r5w2c5XRmz2sNKyx', icon: 'icons/The_Beat-GTAIV.webp' },
            { name: 'The Classics 104.1', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/TheClassics.webp' },
            { name: 'Electro-Choc Fusion FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/Electrochock.webp' },
            { name: 'International Funk 99', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/IF99.webp' },
            { name: 'Independence FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'icons/IndependenceFM.webp' },
            { name: 'Integrity 2.0', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'icons/Integrity.webp' },
            { name: 'Jazz Nation Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/JazzNationRadio-GTAIV-Logo.webp' },
            { name: 'The Journey', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/TheJourney.webp' },
            { name: 'K109 The Studio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/K109.webp' },
            { name: 'Liberty City Hardcore', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/Lchc.webp' },
            { name: 'Liberty Rock Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'icons/Liberty_Rock_Radio.webp' },
            { name: 'Massive B Soundsystem', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'icons/MassiveBSoundsystem.webp' },
            { name: 'Public Liberty Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/Public_Liberty_Radio.webp' },
            { name: 'Radio Broker', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/Radio_Broker.webp' },
            { name: 'RamJam FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/RamJam_FM.webp' },
            { name: 'San Juan Sounds', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/San_Juan_Sounds.webp' },
            { name: 'Self-Actualization FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'icons/Self-Actualization_FM.webp' },
            { name: 'Tuff Gong Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'icons/Tuff_Gong.webp' },
            { name: 'The Vibe', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/TheVibe98.8.webp' },
            { name: 'Vice City FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/ViceCityFM.webp' },
            { name: 'Vladivostok FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/VladivostokFM.webp' },
            { name: 'WKTT Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/WKTTtalkradio.webp' }
        ];

        // Get references to DOM elements
        const audio = document.getElementById('radio-audio');
        const currentStationNameDisplay = document.getElementById('current-station-name');
        const currentStationIconDisplay = document.getElementById('current-station-icon');
        const prevStationIconDisplay = document.getElementById('prev-station-icon');
        const nextStationIconDisplay = document.getElementById('next-station-icon');
        const prevPrevStationIconDisplay = document.getElementById('prev-prev-station-icon');
        const nextNextStationIconDisplay = document.getElementById('next-next-station-icon');
        const playPauseButton = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const toastMessageElement = document.getElementById('toast-message');
        const radioContainer = document.querySelector('.radio-container');

        let currentStationIndex = -1;
        let loadingStationIndex = -1;
        const audioCache = new Map(); // Stores Audio objects for efficient switching

        let toastTimeout;
        /**
         * Displays a toast message at the top of the viewport.
         * @param {string} message - The message to display.
         * @param {number} duration - The duration in milliseconds for which the toast is visible.
         */
        function showToast(message, duration = 2000) {
            console.log("Showing toast:", message);
            clearTimeout(toastTimeout);
            toastMessageElement.textContent = message;
            toastMessageElement.classList.add('show');
            toastTimeout = setTimeout(() => {
                toastMessageElement.classList.remove('show');
            }, duration);
        }

        /**
         * Retrieves an Audio element for a given station index from cache, or creates a new one.
         * Manages the audio cache to keep only relevant adjacent stations loaded.
         * @param {number} index - The index of the station.
         * @returns {HTMLAudioElement | null} The Audio element or null if index is out of bounds.
         */
        function getOrCreateAudioElement(index) {
            if (index < 0 || index >= radioStations.length) {
                return null;
            }

            if (audioCache.has(index)) {
                return audioCache.get(index);
            }

            const station = radioStations[index];
            const newAudio = new Audio(station.src);
            newAudio.preload = 'auto'; // Suggest to preload
            audioCache.set(index, newAudio);

            const current = currentStationIndex;
            const effectiveCurrent = current !== -1 ? current : 0;

            // Define the indices for the 5 visible carousel slots (current, 2 prev, 2 next)
            // These are the only audio elements we actively keep in cache to save memory
            const indicesToKeep = new Set([
                effectiveCurrent,
                (effectiveCurrent - 1 + radioStations.length) % radioStations.length,
                (effectiveCurrent + 1) % radioStations.length,
                (effectiveCurrent - 2 + radioStations.length) % radioStations.length,
                (effectiveCurrent + 2) % radioStations.length
            ]);

            // Clean up old cache entries that are no longer neighbors
            audioCache.forEach((cachedAudio, key) => {
                if (!indicesToKeep.has(key)) {
                    cachedAudio.pause(); // Stop any playback if it was somehow playing
                    cachedAudio.src = ''; // Clear source to release resources
                    audioCache.delete(key);
                }
            });

            return newAudio;
        }

        /**
         * Pre-loads audio for the adjacent stations (2 previous and 2 next) to enable smooth transitions.
         * @param {number} currentIndex - The index of the currently active station.
         */
        function preloadNeighbors(currentIndex) {
            if (radioStations.length < 1) return;

            // Indices to preload: prev, next, prev-prev, next-next
            const indicesToPreload = [
                (currentIndex - 1 + radioStations.length) % radioStations.length,
                (currentIndex + 1) % radioStations.length,
                (currentIndex - 2 + radioStations.length) % radioStations.length,
                (currentIndex + 2) % radioStations.length
            ];

            indicesToPreload.forEach(index => {
                const audioToPreload = getOrCreateAudioElement(index);
                // Only load if the audio element exists and hasn't already loaded enough data
                if (audioToPreload && audioToPreload.readyState < 2) { // READY_STATE_HAVE_CURRENT_DATA
                    audioToPreload.load();
                }
            });
        }

        /**
         * Updates the displayed icons in the carousel for the current, previous, and next stations.
         * Handles circular indexing for seamless looping.
         * @param {number} index - The index of the currently active station.
         */
        function updateIconCarousel(index) {
            if (radioStations.length === 0) {
                // Display generic placeholders if no stations are defined
                currentStationIconDisplay.src = "https://placehold.co/120x120/4299e1/ffffff?text=Icon";
                currentStationIconDisplay.alt = "Station Icon";
                prevStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Prev";
                nextStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Next";
                prevPrevStationIconDisplay.src = "https://placehold.co/60x60/6B7280/FFFFFF?text=P-P";
                nextNextStationIconDisplay.src = "https://placehold.co/60x60/6B7280/FFFFFF?text=N-N";
                // Ensure opacities are set correctly for initial empty state
                prevStationIconDisplay.style.opacity = '0.4';
                nextStationIconDisplay.style.opacity = '0.4';
                currentStationIconDisplay.style.opacity = '1';
                prevPrevStationIconDisplay.style.opacity = '0.15';
                nextNextStationIconDisplay.style.opacity = '0.15';
                return;
            }

            // Helper to get circular index for any given offset
            const getCircularIndex = (i) => (i + radioStations.length) % radioStations.length;

            // Use 0 for initial display if no station is active yet, otherwise use current index
            let displayIndex = index === -1 ? 0 : index;

            // Calculate indices for all 5 display slots
            let prevPrevIndex = getCircularIndex(displayIndex - 2);
            let prevIndex = getCircularIndex(displayIndex - 1);
            let nextIndex = getCircularIndex(displayIndex + 1);
            let nextNextIndex = getCircularIndex(displayIndex + 2);

            // Set sources and alt text for all five icons
            prevPrevStationIconDisplay.src = radioStations[prevPrevIndex].icon;
            prevPrevStationIconDisplay.alt = `${radioStations[prevPrevIndex].name} Icon`;

            prevStationIconDisplay.src = radioStations[prevIndex].icon;
            prevStationIconDisplay.alt = `${radioStations[prevIndex].name} Icon`;

            currentStationIconDisplay.src = radioStations[displayIndex].icon;
            currentStationIconDisplay.alt = `${radioStations[displayIndex].name} Icon`;

            nextStationIconDisplay.src = radioStations[nextIndex].icon;
            nextStationIconDisplay.alt = `${radioStations[nextIndex].name} Icon`;

            nextNextStationIconDisplay.src = radioStations[nextNextIndex].icon;
            nextNextStationIconDisplay.alt = `${radioStations[nextNextIndex].name} Icon`;
        }

        /**
         * Loads and attempts to play a specific radio station.
         * Handles loading states, error reporting, and UI updates.
         * @param {number} index - The index of the station to play.
         * @param {boolean} userInitiated - True if this play request was directly initiated by a user action (click, keypress).
         */
        async function playStation(index, userInitiated = false) {
            // If this station is already the one being loaded/played, do nothing
            if (loadingStationIndex === index && !audio.paused) { // Check if already playing or loading this specific station
                return;
            }

            // Clear any previous loading state and audio playback
            if (audio._currentLoadedMetadataHandler) {
                audio.removeEventListener('loadedmetadata', audio._currentLoadedMetadataHandler);
                audio._currentLoadedMetadataHandler = null; // Clear reference
            }
            if (audio._currentErrorHandler) {
                audio.removeEventListener('error', audio._currentErrorHandler);
                audio._currentErrorHandler = null; // Clear reference
            }

            // Validate index
            if (index < 0 || index >= radioStations.length) {
                console.error('Station index out of bounds:', index);
                showToast(`Error: Invalid station selected.`, 3000);
                currentStationNameDisplay.textContent = "Error";
                return;
            }

            const station = radioStations[index];
            if (!station) {
                console.error('Station not found at index:', index);
                showToast(`Error: Station data missing.`, 3000);
                currentStationNameDisplay.textContent = "Error";
                return;
            }

            // Set new loading state and disable buttons
            loadingStationIndex = index;
            playPauseButton.disabled = true;
            prevButton.disabled = true;
            nextButton.disabled = true;

            showToast(`Loading: ${station.name}...`);
            currentStationNameDisplay.textContent = station.name;
            updateIconCarousel(index);
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');

            audio.src = station.src; // Set the new source

            // Define event handlers for this specific loading attempt
            const handleLoadedMetadata = async () => {
                if (loadingStationIndex !== index) { // Ensure this callback is for the current operation
                    console.log(`Ignoring stale onloadedmetadata for index ${index}. Current loading index is ${loadingStationIndex}.`);
                    return;
                }

                // Set current time to a random spot if duration is available
                if (isFinite(audio.duration) && audio.duration > 0) {
                    const randomTime = Math.random() * audio.duration;
                    audio.currentTime = randomTime;
                    console.log(`Station ${station.name} loaded, set to random time: ${randomTime.toFixed(2)}s`);
                } else {
                    console.warn(`Could not set random time for ${station.name}: duration is not finite or zero.`);
                }

                if (userInitiated) { // Only attempt play if user initiated
                    attemptPlay();
                } else {
                    // If not user-initiated (e.g., initial preload or neighbor preload), just enable buttons
                    playPauseButton.disabled = false;
                    prevButton.disabled = false;
                    nextButton.disabled = false;
                    loadingStationIndex = -1; // Clear loading state
                    // Remove event listeners as they are no longer needed for this load cycle
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('error', handleError);
                }
            };

            const handleError = () => {
                if (loadingStationIndex !== index) { // Ensure this callback is for the current operation
                    console.log(`Ignoring stale onerror for index ${index}. Current loading index is ${loadingStationIndex}.`);
                    return;
                }
                console.error('Error loading audio for station:', station.name);
                currentStationNameDisplay.textContent = `Failed to load station`;
                showToast(`Error: Failed to load station.`, 3000);
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
                loadingStationIndex = -1;
                audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                audio.removeEventListener('error', handleError);
            };

            audio._currentLoadedMetadataHandler = handleLoadedMetadata; // Store reference
            audio._currentErrorHandler = handleError; // Store reference

            audio.addEventListener('loadedmetadata', handleLoadedMetadata);
            audio.addEventListener('error', handleError);

            audio.load();
        }

        /**
         * Attempts to play the audio. Handles potential autoplay policy blocks.
         */
        async function attemptPlay() {
            try {
                await audio.play(); // Attempt to play first

                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                currentStationIndex = loadingStationIndex; // Set current index only upon successful play
                loadingStationIndex = -1; // Clear loading state

                showToast(`Now Playing: ${radioStations[currentStationIndex].name}`, 2000);
                preloadNeighbors(currentStationIndex); // Preload neighbors for the newly playing station
            } catch (error) {
                console.error('Error attempting to play audio (autoplay blocked?):', radioStations[loadingStationIndex].name, error);
                if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                    currentStationNameDisplay.textContent = `Click Play to start!`;
                    showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                } else {
                    currentStationNameDisplay.textContent = `Failed to play station`;
                    showToast(`Error: Could not play station.`, 3000);
                }
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                // Do NOT update currentStationIndex if play failed, keep previous or -1
                loadingStationIndex = -1; // Clear loading state
            } finally {
                playPauseButton.disabled = false; // Re-enable button
                prevButton.disabled = false;
                nextButton.disabled = false;
                // Remove the specific handlers once the attempt is complete
                if (audio._currentLoadedMetadataHandler) {
                    audio.removeEventListener('loadedmetadata', audio._currentLoadedMetadataHandler);
                    audio._currentLoadedMetadataHandler = null;
                }
                if (audio._currentErrorHandler) {
                    audio.removeEventListener('error', audio._currentErrorHandler);
                    audio._currentErrorHandler = null;
                }
            }
        }

        /**
         * Toggles the play/pause state of the current audio.
         * If no station is active, it attempts to play the first one.
         */
        async function togglePlayPause() {
            if (audio.paused) {
                // If no station has been selected yet, play the first one (user initiated)
                if (currentStationIndex === -1 && radioStations.length > 0) {
                    await playStation(0, true); // User initiated
                } else if (currentStationIndex !== -1) {
                    // If a station is selected but paused, try to play/resume it (user initiated)
                    playPauseButton.disabled = true; // Disable button during play attempt
                    try {
                        // Set current time to a random spot if duration is available before playing
                        if (isFinite(audio.duration) && audio.duration > 0) {
                            const randomTime = Math.random() * audio.duration;
                            audio.currentTime = randomTime;
                            console.log(`Resuming from random time: ${randomTime.toFixed(2)}s`);
                        }
                        await audio.play();
                        playIcon.classList.add('hidden');
                        pauseIcon.classList.remove('hidden');
                        showToast(`Resumed: ${radioStations[currentStationIndex].name}`, 2000);
                    } catch (error) {
                        console.error('Error resuming playback (autoplay blocked?):', radioStations[currentStationIndex].name, error);
                        if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                            currentStationNameDisplay.textContent = `Click Play to start!`;
                            showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                        } else {
                            currentStationNameDisplay.textContent = `Failed to resume playback`;
                            showToast(`Error: Could not resume playback.`, 3000);
                        }
                        playIcon.classList.remove('hidden');
                        pauseIcon.classList.add('hidden');
                    } finally {
                        playPauseButton.disabled = false; // Re-enable button
                    }
                }
            } else {
                // If audio is playing, pause it
                audio.pause();
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                if (currentStationIndex !== -1) {
                    showToast(`Paused: ${radioStations[currentStationIndex].name}`, 2000);
                }
            }
        }

        // --- Event Listeners ---
        playPauseButton.addEventListener('click', togglePlayPause);

        prevButton.addEventListener('click', () => {
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }
            let targetIndex;
            if (currentStationIndex === -1) {
                targetIndex = radioStations.length - 1; // Go to last station if none active
            } else {
                targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
            }
            playStation(targetIndex, true); // User initiated
        });

        nextButton.addEventListener('click', () => {
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }
            let targetIndex;
            if (currentStationIndex === -1) {
                targetIndex = 0; // Go to first station if none active
            } else {
                targetIndex = (currentStationIndex + 1) % radioStations.length;
            }
            playStation(targetIndex, true); // User initiated
        });

        // Keyboard navigation for 'Q' key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'q' || event.key === 'Q') {
                event.preventDefault(); // Prevent default browser behavior (e.g., quick find)
                if (radioStations.length === 0) {
                    showToast("No stations available to cycle!", 2000);
                    return;
                }

                let nextIndex;
                if (currentStationIndex === -1) {
                    nextIndex = 0;
                } else {
                    nextIndex = (currentStationIndex + 1) % radioStations.length;
                }
                playStation(nextIndex, true); // User initiated
            }
        });

        // Mouse wheel navigation over the radio container
        radioContainer.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling
            if (radioStations.length === 0) {
                showToast("No stations available to cycle!", 2000);
                return;
            }

            let targetIndex;
            if (event.deltaY > 0) { // Scroll down (next station)
                if (currentStationIndex === -1) {
                    targetIndex = 0;
                } else {
                    targetIndex = (currentStationIndex + 1) % radioStations.length;
                }
            } else { // Scroll up (previous station)
                if (currentStationIndex === -1) {
                    targetIndex = radioStations.length - 1;
                } else {
                    targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
                }
            }
            playStation(targetIndex, true); // User initiated
        });

        // Handle audio ending (DO NOT AUTO-REPLAY)
        audio.addEventListener('ended', () => {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
            currentStationNameDisplay.textContent = "Press Play"; // Prompt user to play again
            showToast(`Station ended. Press Play to restart.`, 3000);
            // Optionally, you could automatically go to the next station here if desired,
            // but for autoplay policy compliance, it's safer to wait for user interaction.
            // If you want to auto-advance, call playStation((currentStationIndex + 1) % radioStations.length, false);
        });

        // Update UI when audio is paused
        audio.addEventListener('pause', () => {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        });

        // Update UI when audio starts playing
        audio.addEventListener('play', () => {
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
        });

        // --- Initialization on Page Load ---
        window.onload = () => {
            if (radioStations.length > 0) {
                // Set the current station index to the first station for initial display
                currentStationIndex = 0;
                // Update the carousel to show the first station's icons and its neighbors
                updateIconCarousel(currentStationIndex);
                // Set the initial display text
                currentStationNameDisplay.textContent = "Press Play"; // Initial prompt

                // Proactively set the main audio element's source to the first station's audio
                audio.src = radioStations[0].src;

                // Add a one-time listener to set random time when metadata is loaded for the first station
                const setInitialRandomTime = () => {
                    if (isFinite(audio.duration) && audio.duration > 0) {
                        const randomTime = Math.random() * audio.duration;
                        audio.currentTime = randomTime;
                        console.log(`Initial station loaded, set to random time: ${randomTime.toFixed(2)}s`);
                    }
                    audio.removeEventListener('loadedmetadata', setInitialRandomTime); // Remove listener after first use
                };

                // Check if metadata is already loaded (e.g., from cache)
                if (audio.readyState >= audio.HAVE_METADATA) {
                    setInitialRandomTime(); // If ready, set immediately
                } else {
                    audio.addEventListener('loadedmetadata', setInitialRandomTime); // Otherwise, wait for event
                }

                // Explicitly tell the browser to start loading/buffering.
                // This does NOT attempt to play the audio automatically, only loads it.
                audio.load();

                // Proactively preload audio for adjacent stations (already handled by preloadNeighbors)
                preloadNeighbors(currentStationIndex);

                // Preload ALL station icons by creating Image objects
                // This ensures all icons are fetched by the browser as soon as possible
                radioStations.forEach(station => {
                    const img = new Image();
                    img.src = station.icon;
                    // You can add img.onload or img.onerror here if you need to track icon loading status
                });

            } else {
                currentStationNameDisplay.textContent = "No stations available!";
                updateIconCarousel(-1); // Show generic placeholders if no stations are defined
            }
        };
    </script>
</body>

</html>
