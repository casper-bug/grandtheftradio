<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA IV Radio</title>
     <link rel="icon" type="image/x-icon" href="icons/radio.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Changed background to a subtle radial gradient for a sleek, modern feel */
            background: radial-gradient(circle at center, #1a1a1a 0%, #0d0d0d 100%);
            color: #e2e8f0;
            /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            /* Removed overflow: hidden; to allow scrolling */
        }

        .radio-container {
            /* Changed background to a semi-transparent dark grey for an aero effect */
            background-color: rgba(51, 51, 51, 0.6);
            /* Added backdrop-filter for frosted glass effect */
            backdrop-filter: blur(15px); /* Increased blur for more pronounced effect */
            -webkit-backdrop-filter: blur(15px); /* Safari support */
            padding: 30px;
            border-radius: 20px; /* Slightly more rounded corners */
            /* Enhanced box-shadow for a floating, modern look */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.05); /* Added subtle white border for depth */
            max-width: 600px;
            width: 100%;
            text-align: center;
            border: none; /* Removed solid border, replaced by box-shadow's inner border */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-left: 15px;
            padding-right: 15px;
            margin-top: 50px;
        }

        .icon-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
            /* Default gap */

            /* Responsive gap for smaller screens */
            @media (max-width: 480px) {
                gap: 5px;
                /* Smaller gap on very small screens */
            }
        }

        .station-icon-base {
            /* Base styles for all icons */
            object-fit: contain;
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
            flex-shrink: 0;
        }

        .station-icon-outer-faded {
            /* Responsive width using clamp: min-size, preferred-size (vw), max-size */
            width: clamp(40px, 15vw, 80px);
            height: clamp(40px, 15vw, 80px);
            opacity: 0.15;
        }

        .station-icon-faded {
            width: clamp(60px, 20vw, 100px);
            height: clamp(60px, 20vw, 100px);
            opacity: 0.4;
        }

        .station-icon {
            width: clamp(80px, 30vw, 160px);
            height: clamp(80px, 30vw, 160px);
            opacity: 1;
        }

        .station-icon:hover {
            transform: scale(1.05);
        }

        .station-name-display {
            /* Responsive font size using clamp */
            font-size: clamp(1.2rem, 5vw, 2.5rem);
            font-weight: 800;
            color: #4299e1;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(66, 153, 225, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .radio-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            gap: 1rem;
        }

        @media (max-width: 640px) {
            .radio-controls {
                gap: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .radio-controls {
                gap: 0.5rem;
            }
        }

        .control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            flex-shrink: 1;
            min-width: 48px;
            max-width: 80px;
            height: 50px;
            padding: 0;
        }

        .control-button:hover {
            background-color: #636b77;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
        }

        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #play-pause-button {
            min-width: 60px;
            max-width: 100px;
        }

        .hidden {
            display: none !important;
        }

        .toast-message {
            position: fixed;
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1000;
            white-space: nowrap;
        }

        .toast-message.show {
            opacity: 1;
            visibility: visible;
        }

        .play-icon,
        .pause-icon,
        .prev-icon,
        .next-icon {
            fill: white;
            width: 24px;
            height: 24px;
        }
    </style>
</head>

<body class="antialiased">
    <div class="radio-container">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">GTA IV Radio</h1>

        <div class="icon-carousel">
            <img id="prev-prev-station-icon" src="" alt="Previous Previous Station Icon"
                class="station-icon-outer-faded station-icon-base">
            <img id="prev-station-icon" src="" alt="Previous Station Icon" class="station-icon-faded station-icon-base">
            <img id="current-station-icon" src="" alt="Current Station Icon" class="station-icon station-icon-base">
            <img id="next-station-icon" src="" alt="Next Station Icon" class="station-icon-faded station-icon-base">
            <img id="next-next-station-icon" src="" alt="Next Next Station Icon"
                class="station-icon-outer-faded station-icon-base">
        </div>

        <div class="mb-6">
            <p class="text-lg font-semibold mb-2">Now Playing:</p>
            <p id="current-station-name" class="station-name-display">Select a Station</p>
        </div>

        <audio id="radio-audio" class="w-full mb-6 hidden" controls></audio>

        <div class="flex items-center justify-center w-full radio-controls">
            <button id="prev-button" class="control-button">
                <svg class="prev-icon" viewBox="0 0 24 24">
                    <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" />
                </svg>
            </button>
            <button id="play-pause-button" class="control-button">
                <svg id="play-icon" class="play-icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <svg id="pause-icon" class="pause-icon hidden" viewBox="0 0 24 24">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                </svg>
            </button>
            <button id="next-button" class="control-button">
                <svg class="next-icon" viewBox="0 0 24 24">
                    <path d="M8.59 16.59L13.17 12l-4.58-4.59L10 6l6 6-6 6z" />
                </svg>
            </button>
        </div>

        <div id="toast-message" class="toast-message"></div>

    </div>

    <script>

        const radioStations = [
            // Changed the source for 'The Beat 102.7' to a valid MP3 URL
            { name: 'The Beat 102.7', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/The_Beat-GTAIV.webp' },
            { name: 'The Classics 104.1', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/TheClassics.webp' },
            { name: 'Electro-Choc Fusion FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/Electrochock.webp' },
            { name: 'International Funk', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/IF99.webp' },
            { name: 'Independence FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'icons/IndependenceFM.webp' },
            { name: 'Integrity 2.0', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'icons/Integrity.webp' },
            { name: 'Jazz Nation Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/JazzNationRadio-GTAIV-Logo.webp' },
            { name: 'The Journey', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/TheJourney.webp' },
            { name: 'K109 The Studio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/K109.webp' },
            { name: 'Liberty City Hardcore', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/Lchc.webp' },
            { name: 'Liberty Rock Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'icons/Liberty_Rock_Radio.webp' },
            // FIX: Changed local path to a valid public URL for 'Massive B Soundsystem'
            { name: 'Massive B Soundsystem', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-7.mp3', icon: 'icons/MassiveBSoundsystem.webp' },
            { name: 'Public Liberty Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/Public_Liberty_Radio.webp' },
            { name: 'Radio Broker', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/Radio_Broker.webp' },
            { name: 'RamJam FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/RamJam_FM.webp' },
            { name: 'San Juan Sounds', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/San_Juan_Sounds.webp' },
            { name: 'Self-Actualization FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'icons/Self-Actualization_FM.webp' },
            { name: 'Tuff Gong Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'icons/Tuff_Gong.webp' },
            { name: 'The Vibe', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'icons/TheVibe98.8.webp' },
            { name: 'Vice City FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'icons/ViceCityFM.webp' },
            { name: 'Vladivostok FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'icons/VladivostokFM.webp' },
            { name: 'WKTT Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'icons/WKTTtalkradio.webp' }
        ];

        // Get references to DOM elements
        const audio = document.getElementById('radio-audio');
        const currentStationNameDisplay = document.getElementById('current-station-name');
        const currentStationIconDisplay = document.getElementById('current-station-icon');
        const prevStationIconDisplay = document.getElementById('prev-station-icon');
        const nextStationIconDisplay = document.getElementById('next-station-icon');
        const prevPrevStationIconDisplay = document.getElementById('prev-prev-station-icon');
        const nextNextStationIconDisplay = document.getElementById('next-next-station-icon');
        const playPauseButton = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const toastMessageElement = document.getElementById('toast-message');
        const radioContainer = document.querySelector('.radio-container');

        let currentStationIndex = -1;
        // Removed activeAudioObject, it's redundant with 'audio' being the main player.

        let toastTimeout;
        let audioLoadTimeout; // Debounce timeout for audio loading
        // Increased debounce delay slightly to give more time for rapid scrolling/clicking
        const audioLoadDelay = 300; // Debounce delay in milliseconds for audio loading

        // Moved audioCache to global scope
        const audioCache = new Map(); // Stores Audio objects for efficient switching


        /**
         * Displays a toast message at the top of the viewport.
         * @param {string} message - The message to display.
         * @param {number} duration - The duration in milliseconds for which the toast is visible.
         * @param {boolean} sticky - If true, the toast will not auto-hide.
         */
        function showToast(message, duration = 2000, sticky = false) {
            console.log("Showing toast:", message);
            clearTimeout(toastTimeout);
            toastMessageElement.textContent = message;
            toastMessageElement.classList.add('show');
            if (!sticky) {
                toastTimeout = setTimeout(() => {
                    toastMessageElement.classList.remove('show');
                }, duration);
            }
        }

        /**
         * Hides the currently displayed toast message.
         */
        function hideToast() {
            clearTimeout(toastTimeout);
            toastMessageElement.classList.remove('show');
            toastMessageElement.textContent = ''; // Clear text content
        }

        /**
         * Retrieves an Audio element for a given station index from cache, or creates a new one.
         * Manages the audio cache to keep only relevant adjacent stations loaded.
         * @param {number} index - The index of the station.
         * @returns {HTMLAudioElement | null} The Audio element or null if index is out of bounds.
         */
        function getOrCreateAudioElement(index) {
            if (index < 0 || index >= radioStations.length) {
                return null;
            }

            if (audioCache.has(index)) {
                return audioCache.get(index);
            }

            const station = radioStations[index];
            const newAudio = new Audio(station.src);
            newAudio.preload = 'auto'; // Suggest to preload
            audioCache.set(index, newAudio);

            const currentVisualIndex = currentStationIndex; // Use the visually selected index
            const indicesToKeep = new Set();
            if (radioStations.length > 0) {
                const effectiveCurrent = currentVisualIndex !== -1 ? currentVisualIndex : 0;
                indicesToKeep.add(effectiveCurrent);
                indicesToKeep.add((effectiveCurrent - 1 + radioStations.length) % radioStations.length);
                indicesToKeep.add((effectiveCurrent + 1) % radioStations.length);
                indicesToKeep.add((effectiveCurrent - 2 + radioStations.length) % radioStations.length);
                indicesToKeep.add((effectiveCurrent + 2) % radioStations.length);
            }

            audioCache.forEach((cachedAudio, key) => {
                // Ensure we don't remove the currently playing audio object if it's different from the new target
                // Now that `audio` is the single source of truth for playback, we check against `audio.src`
                if (!indicesToKeep.has(key) && (audio.src !== cachedAudio.src)) {
                    cachedAudio.pause(); // Stop any playback if it was somehow playing
                    cachedAudio.src = ''; // Clear source to release resources
                    audioCache.delete(key);
                }
            });

            return newAudio;
        }

        /**
         * Pre-loads audio for the adjacent stations (2 previous and 2 next) to enable smooth transitions.
         * This loads into the cache, not directly to the main audio element.
         * @param {number} currentIndex - The index of the currently active station.
         */
        function preloadNeighbors(currentIndex) {
            if (radioStations.length < 1) return;

            const indicesToPreload = [
                (currentIndex - 1 + radioStations.length) % radioStations.length,
                (currentIndex + 1) % radioStations.length,
                (currentIndex - 2 + radioStations.length) % radioStations.length,
                (currentIndex + 2) % radioStations.length
            ];

            indicesToPreload.forEach(index => {
                const audioToPreload = getOrCreateAudioElement(index);
                if (audioToPreload && audioToPreload.readyState < 2) { // READY_STATE_HAVE_CURRENT_DATA
                    audioToPreload.load();
                }
            });
        }

        /**
         * Updates the displayed icons in the carousel for the current, previous, and next stations.
         * Handles circular indexing for seamless looping.
         * @param {number} index - The index of the currently active station.
         */
        function updateIconCarousel(index) {
            if (radioStations.length === 0) {
                /* Display generic placeholders if no stations are defined */
                currentStationIconDisplay.src = "https://placehold.co/120x120/4299e1/ffffff?text=Icon";
                currentStationIconDisplay.alt = "Station Icon";
                prevStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Prev";
                nextStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Next";
                prevPrevStationIconDisplay.src = "https://placehold.co/60x60/6B7280/FFFFFF?text=P-P";
                nextNextStationIconDisplay.src = "https://placehold.co/60x60/6B7280/FFFFFF?text=N-N";
                /* Ensure opacities are set correctly for initial empty state */
                prevStationIconDisplay.style.opacity = '0.4';
                nextStationIconDisplay.style.opacity = '0.4';
                currentStationIconDisplay.style.opacity = '1';
                prevPrevStationIconDisplay.style.opacity = '0.15';
                nextNextStationIconDisplay.style.opacity = '0.15';
                return;
            }

            /* Helper to get circular index for any given offset */
            const getCircularIndex = (i) => (i + radioStations.length) % radioStations.length;

            /* Use 0 for initial display if no station is active yet, otherwise use current index */
            let displayIndex = index === -1 ? 0 : index;

            /* Calculate indices for all 5 display slots */
            let prevPrevIndex = getCircularIndex(displayIndex - 2);
            let prevIndex = getCircularIndex(displayIndex - 1);
            let nextIndex = getCircularIndex(displayIndex + 1);
            let nextNextIndex = getCircularIndex(displayIndex + 2);

            /* Set sources and alt text for all five icons */
            prevPrevStationIconDisplay.src = radioStations[prevPrevIndex].icon;
            prevPrevStationIconDisplay.alt = `${radioStations[prevPrevIndex].name} Icon`;

            prevStationIconDisplay.src = radioStations[prevIndex].icon;
            prevStationIconDisplay.alt = `${radioStations[prevIndex].name} Icon`;

            currentStationIconDisplay.src = radioStations[displayIndex].icon;
            currentStationIconDisplay.alt = `${radioStations[displayIndex].name} Icon`;

            nextStationIconDisplay.src = radioStations[nextIndex].icon;
            nextStationIconDisplay.alt = `${radioStations[nextIndex].name} Icon`;

            nextNextStationIconDisplay.src = radioStations[nextNextIndex].icon;
            nextNextStationIconDisplay.alt = `${radioStations[nextNextIndex].name} Icon`;
        }

        /**
         * Loads a specific radio station's audio into the main audio element and prepares it.
         * This function does NOT attempt to play it automatically.
         * It updates the main 'audio' element's src.
         * @param {number} index - The index of the station to load.
         * @returns {Promise<boolean>} Resolves true if loaded successfully, false otherwise.
         */
        async function loadStation(index) {
            if (index < 0 || index >= radioStations.length) {
                console.error('loadStation: Station index out of bounds:', index);
                hideToast(); /* Hide any loading toast */
                showToast(`Error: Invalid station selected.`, 3000);
                return false;
            }

            const station = radioStations[index];

            /* If the main audio element's source is already this station and it's ready, do nothing. */
            if (audio.src === station.src && audio.readyState >= audio.HAVE_METADATA) {
                console.log(`Station ${station.name} already loaded into main player.`);
                hideToast(); /* Hide any loading toast */
                return true;
            }

            /* Pause the currently playing audio */
            audio.pause();
            /* Clear its source to ensure a fresh load and abort any current download */
            audio.src = '';
            /* Calling load() after clearing src is essential to truly abort ongoing downloads */
            audio.load();

            /* Temporarily disable buttons while we prepare the audio */
            playPauseButton.disabled = true;
            prevButton.disabled = true;
            nextButton.disabled = true;

            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');

            audio.src = station.src; /* Set the new source for the main audio element */

            try {
                await new Promise((resolve, reject) => {
                    const onLoadedMetadata = () => {
                        audio.removeEventListener('loadedmetadata', onLoadedMetadata);
                        audio.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = (e) => { /* Capture the event object */
                        audio.removeEventListener('loadedmetadata', onLoadedMetadata);
                        audio.removeEventListener('error', onError);
                        console.error('Audio loading error event:', e); /* Log the event for more details */
                        reject(new Error(`Failed to load metadata for ${station.name}`));
                    };
                    audio.addEventListener('loadedmetadata', onLoadedMetadata);
                    audio.addEventListener('error', onError);
                    /* Re-call load() after setting src to ensure it starts loading */
                    audio.load();
                });

                /* Set random time for the main audio element if it's not already playing */
                if (isFinite(audio.duration) && audio.duration > 0 && audio.paused) {
                    const randomTime = Math.random() * audio.duration;
                    audio.currentTime = randomTime;
                    console.log(`Station ${station.name} prepared, set to random time: ${randomTime.toFixed(2)}s`);
                }

                /* Station is loaded, update currentStationIndex and enable buttons */
                currentStationIndex = index; /* Confirm currentStationIndex is the one loaded */
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
                hideToast(); /* Hide loading toast */
                showToast(`Ready to play: ${radioStations[currentStationIndex].name}`, 1500);
                preloadNeighbors(currentStationIndex); /* Preload neighbors for the newly prepared station */
                return true;

            } catch (error) {
                console.error('Error loading audio for station:', station.name, error);
                hideToast(); /* Hide loading toast */
                showToast(`Failed to load ${station.name}. Please press Play.`, 5000);
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
                audio.src = ''; /* Clear source on error */
                return false;
            }
        }


        /**
         * Attempts to play the current audio. Handles potential autoplay policy blocks.
         */
        async function attemptPlay() {
            if (currentStationIndex === -1 || audio.src === '') {
                hideToast(); /* Hide any loading toast */
                showToast("No station selected or loaded. Please select a station and press Play.", 3000);
                return;
            }

            /* This check should ideally be redundant if loadStation was awaited correctly
             * but keeping it as a safeguard. */
            if (audio.readyState < audio.HAVE_METADATA) {
                console.warn("Attempted to play audio before metadata loaded. This should not happen if loadStation was awaited.");
                hideToast(); /* Hide any stale toast */
                showToast(`Audio not fully ready for ${radioStations[currentStationIndex].name}. Please try again.`, 3000);
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
                return;
            }

            playPauseButton.disabled = true; /* Disable button during play attempt */
            try {
                await audio.play(); /* Attempt to play the main audio element */

                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                hideToast(); /* Hide loading toast */
                showToast(`Now Playing: ${radioStations[currentStationIndex].name}`, 2000);
            } catch (error) {
                console.error('Error attempting to play audio (autoplay blocked?):', radioStations[currentStationIndex].name, error);
                hideToast(); /* Hide loading toast */
                if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                    showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                } else if (error.name === "AbortError" && error.message.includes("interrupted by a call to pause()")) {
                    /* This error means a play was initiated but then immediately paused.
                     * This should be rare with the improved interrupt logic. */
                    console.warn("Play request was interrupted by a pause. This might be due to rapid user interaction.");
                    showToast(`Playback interrupted. Please press Play again.`, 3000);
                }
                else {
                    showToast(`Failed to play ${radioStations[currentStationIndex].name}. Please press Play.`, 3000);
                }
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                audio.pause(); /* Ensure main audio is paused on error */
            } finally {
                playPauseButton.disabled = false; /* Re-enable button */
            }
        }

        /**
         * Toggles the play/pause state of the current audio.
         * This is the ONLY function that should initiate audio loading and playback.
         */
        async function togglePlayPause() {
            if (audio.paused) {
                let targetIndexToLoad = currentStationIndex;

                /* If no station is visually selected, default to the first one. */
                if (currentStationIndex === -1 && radioStations.length > 0) {
                    targetIndexToLoad = 0;
                    /* Update visuals immediately for the default station */
                    currentStationNameDisplay.textContent = radioStations[targetIndexToLoad].name;
                    updateIconCarousel(targetIndexToLoad);
                    currentStationIndex = targetIndexToLoad; /* Update currentStationIndex */
                }

                /* If the current station's audio is not loaded into the main audio element, load it.
                 * Check audio.src directly against the target station's src. */
                const needsLoading = (targetIndexToLoad !== -1 && audio.src !== radioStations[targetIndexToLoad].src) || (targetIndexToLoad !== -1 && audio.readyState < audio.HAVE_METADATA);

                if (needsLoading) {
                    showToast(`Loading: ${radioStations[targetIndexToLoad].name}...`, 2000, true); /* Sticky loading toast */
                    const loadSuccess = await loadStation(targetIndexToLoad);
                    if (!loadSuccess) {
                        /* loadStation already handled error toast and button re-enabling */
                        return; /* Exit if loading failed */
                    }
                }

                /* After ensuring the correct station is loaded (or loading), attempt to play. */
                if (currentStationIndex !== -1 && audio.readyState >= audio.HAVE_METADATA) { /* Only attempt play if metadata is available */
                    await attemptPlay();
                } else if (currentStationIndex !== -1) {
                     /* If we reach here, it means loadStation might have failed or is still pending.
                      * The error toast from loadStation should cover this. */
                     console.log("Audio not ready to play after load attempt (should be covered by loadStation error).");
                     hideToast(); /* Ensure toast is hidden */
                     showToast(`Failed to play ${radioStations[currentStationIndex].name}. Please press Play.`, 3000);
                     playPauseButton.disabled = false;
                     prevButton.disabled = false;
                     nextButton.disabled = false;
                }


            } else {
                /* If audio is playing, pause it */
                audio.pause();
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                if (currentStationIndex !== -1) {
                    showToast(`Paused: ${radioStations[currentStationIndex].name}`, 2000);
                }
            }
        }

        /**
         * Debounced function to handle station switching.
         * Updates UI immediately. Does NOT trigger audio loading.
         * @param {number} index - The index of the station to switch to.
         */
        function debouncedSwitchStation(index) {
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }

            /* --- Interrupt current audio operation --- */
            /* If audio is currently loading or playing, stop it immediately.
             * Check if audio.src is set (meaning a load was initiated) or if it's currently playing. */
            if (!audio.paused || (audio.src !== '' && audio.readyState < audio.HAVE_METADATA)) {
                console.log("Interrupting current audio operation (playing or loading).");
                audio.pause(); /* Pause if playing */
                audio.src = ''; /* Clear source to abort current download */
                audio.load();   /* Call load() to ensure the abort takes effect */
                hideToast();    /* Hide any ongoing loading/playing toast */
                /* Re-enable buttons if they were disabled by a previous load/play attempt */
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
            }
            /* --- End Interrupt --- */


            /* Immediately update UI for responsiveness */
            currentStationIndex = index; /* Update the current station index visually */
            currentStationNameDisplay.textContent = radioStations[index].name;
            updateIconCarousel(index);

            /* Ensure play icon is visible, as audio is not automatically playing on switch */
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');

            /* Show appropriate toast message based on whether audio was playing */
            if (!audio.paused) { /* This check is redundant due to the interrupt block above, but harmless. */
                showToast(`Switched to: ${radioStations[currentStationIndex].name}. Press Play to listen.`, 2000);
            } else {
                showToast(`Selected: ${radioStations[currentStationIndex].name}. Press Play to listen.`, 2000);
            }

            /* Clear any existing timeout for audio loading, as we don't want to load on every visual switch */
            clearTimeout(audioLoadTimeout);

            /* Schedule the audio loading after a short delay.
             * This prepares the audio for playback when the user eventually presses play,
             * but doesn't auto-play it. */
            audioLoadTimeout = setTimeout(() => {
                /* Only load if the audio source is not already set to this station's source on the main audio element
                 * This will trigger loadStation if needed when play is pressed. */
                const targetStationSrc = radioStations[index].src;
                if (audio.src !== targetStationSrc) {
                    /* Preload into cache for faster access later, but don't set main audio.src yet */
                    const cachedAudio = getOrCreateAudioElement(index);
                    if (cachedAudio && cachedAudio.readyState < cachedAudio.HAVE_METADATA) {
                        cachedAudio.load();
                    }
                }
            }, audioLoadDelay);
        }

        /* --- Event Listeners --- */
        playPauseButton.addEventListener('click', togglePlayPause);

        prevButton.addEventListener('click', () => {
            let targetIndex;
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }
            if (currentStationIndex === -1) {
                targetIndex = radioStations.length - 1; /* Go to last station if none active */
            } else {
                targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
            }
            debouncedSwitchStation(targetIndex);
        });

        nextButton.addEventListener('click', () => {
            let targetIndex;
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }
            if (currentStationIndex === -1) {
                targetIndex = 0; /* Go to first station if none active */
            } else {
                targetIndex = (currentStationIndex + 1) % radioStations.length;
            }
            debouncedSwitchStation(targetIndex);
        });

        /* Keyboard navigation for 'Q' key */
        document.addEventListener('keydown', (event) => {
            if (event.key === 'q' || event.key === 'Q') {
                event.preventDefault(); /* Prevent default browser behavior (e.g., quick find) */
                if (radioStations.length === 0) {
                    showToast("No stations available to cycle!", 2000);
                    return;
                }
                let nextIndex;
                if (currentStationIndex === -1) {
                    nextIndex = 0;
                } else {
                    nextIndex = (currentStationIndex + 1) % radioStations.length;
                }
                debouncedSwitchStation(nextIndex);
            }
        });

        /* Mouse wheel navigation over the radio container */
        radioContainer.addEventListener('wheel', (event) => {
            /* Do NOT preventDefault here to allow page scrolling */
            /* event.preventDefault(); */
            if (radioStations.length === 0) {
                showToast("No stations available to cycle!", 2000);
                return;
            }
            let targetIndex;
            if (event.deltaY > 0) { /* Scroll down (next station) */
                if (currentStationIndex === -1) {
                    targetIndex = 0;
                } else {
                    targetIndex = (currentStationIndex + 1) % radioStations.length;
                }
            } else { /* Scroll up (previous station) */
                if (currentStationIndex === -1) {
                    targetIndex = radioStations.length - 1;
                } else {
                    targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
                }
            }
            debouncedSwitchStation(targetIndex);
        });

        /* Handle audio ending (DO NOT AUTO-REPLAY) */
        audio.addEventListener('ended', () => {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
            currentStationNameDisplay.textContent = "Press Play"; /* Prompt user to play again */
            hideToast(); /* Hide any toast */
            showToast(`Station ended. Press Play to restart.`, 3000);
        });

        /* Update UI when audio is paused */
        audio.addEventListener('pause', () => {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        });

        /* Update UI when audio starts playing */
        audio.addEventListener('play', () => {
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
            hideToast(); /* Hide any loading toast when playback starts */
        });

        /* --- Initialization on Page Load --- */
        window.onload = () => {
            if (radioStations.length > 0) {
                /* Set the current station index to the first station for initial display */
                currentStationIndex = 0;
                /* Update the carousel to show the first station's icons and its neighbors */
                updateIconCarousel(currentStationIndex);
                /* Set the initial display text */
                currentStationNameDisplay.textContent = "Press Play"; /* Initial prompt */

                /* Proactively preload audio for adjacent stations (already handled by preloadNeighbors)
                 * This prepares them in the background without setting the main audio.src */
                preloadNeighbors(currentStationIndex);

                /* Preload ALL station icons by creating Image objects
                 * This ensures all icons are fetched by the browser as soon as possible */
                radioStations.forEach(station => {
                    const img = new Image();
                    img.src = station.icon;
                    /* You can add img.onload or img.onerror here if you need to track icon loading status */
                });

            } else {
                currentStationNameDisplay.textContent = "No stations available!";
                updateIconCarousel(-1); /* Show generic placeholders if no stations are defined */
            }
        };
    </script>
</body>

</html>
