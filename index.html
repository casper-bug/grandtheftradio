<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA-Style Radio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent body scroll if content slightly overflows */
        }
        .radio-container {
            background-color: #333333; /* Dark Grey background */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            text-align: center;
            border: 2px solid #4a5568;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* For toast positioning */
        }
        .icon-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        .station-icon-faded {
            width: 80px; /* Size for direct faded neighbors */
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #4a5568; /* Darker border for faded icons */
            opacity: 0.4; /* Darker opacity for direct neighbors */
            margin: 0 10px; /* Adjust margin for more icons */
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
        }
        .station-icon-outer-faded { /* New class for outermost faded icons */
            width: 60px; /* Smaller size for outer faded icons */
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #4a5568; /* Thinner border for outer faded icons */
            opacity: 0.15; /* Even darker/more faded opacity */
            margin: 0 5px; /* Smaller margin for outer icons */
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
        }
        .station-icon {
            width: 120px; /* Main icon size */
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #4299e1; /* Blue border for the current icon */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.6); /* White glow */
            opacity: 1; /* Full opacity */
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out;
        }
        .station-icon:hover {
            transform: scale(1.05);
        }
        .station-name-display {
            font-size: 2.5rem; /* Larger font for station name */
            font-weight: 800;
            color: #4299e1; /* Blue for active station name */
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(66, 153, 225, 0.5);
        }
        .control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px; /* Fixed width for control buttons */
            height: 50px; /* Fixed height for control buttons */
            padding: 0; /* Remove padding to center icon */
        }
        .control-button:hover {
            background-color: #636b77;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
        }
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        /* Specific styling for the play/pause button to be slightly larger */
        #play-pause-button {
            width: 80px;
        }
        /* Hidden elements */
        .hidden {
            display: none !important;
        }

        /* Toast styles */
        .toast-message {
            position: absolute;
            top: 20px; /* Positioned at the top */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1000;
            white-space: nowrap;
        }
        .toast-message.show {
            opacity: 1;
            visibility: visible;
        }
        .play-icon, .pause-icon, .prev-icon, .next-icon {
            fill: white; /* White SVG icons */
            width: 24px; /* Size of the SVG icon */
            height: 24px;
        }
    </style>
</head>
<body class="antialiased">
    <div class="radio-container">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">GTA Radio</h1>

        <div class="icon-carousel">
            <img id="prev-prev-station-icon" src="" alt="Previous Previous Station Icon" class="station-icon-outer-faded">
            <img id="prev-station-icon" src="" alt="Previous Station Icon" class="station-icon-faded">
            <img id="current-station-icon" src="" alt="Current Station Icon" class="station-icon">
            <img id="next-station-icon" src="" alt="Next Station Icon" class="station-icon-faded">
            <img id="next-next-station-icon" src="" alt="Next Next Station Icon" class="station-icon-outer-faded">
        </div>

        <div class="mb-6">
            <p class="text-lg font-semibold mb-2">Now Playing:</p>
            <p id="current-station-name" class="station-name-display">Select a Station</p>
        </div>

        <audio id="radio-audio" class="w-full mb-6 hidden" controls></audio>

        <div class="flex items-center justify-center gap-4 w-full">
            <button id="prev-button" class="control-button">
                <svg class="prev-icon" viewBox="0 0 24 24">
                    <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/>
                </svg>
            </button>
            <button id="play-pause-button" class="control-button">
                <svg id="play-icon" class="play-icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg id="pause-icon" class="pause-icon hidden" viewBox="0 0 24 24">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                </svg>
            </button>
            <button id="next-button" class="control-button">
                <svg class="next-icon" viewBox="0 0 24 24">
                    <path d="M8.59 16.59L13.17 12l-4.58-4.59L10 6l6 6-6 6z"/>
                </svg>
            </button>
        </div>

        <div id="toast-message" class="toast-message"></div>

    </div>

    <script>
        /*
         * =====================================================================
         * RADIO STATION CONFIGURATION
         * =====================================================================
         *
         * This is the dedicated section for defining all your radio stations.
         *
         * Each station is an object within this 'radioStations' array.
         *
         * To add, remove, or modify stations:
         *
         * 1.  Add a new station:
         * Simply add a new object to the array, following the structure below.
         *
         * 2.  Modify an existing station:
         * Change the 'name', 'src', or 'icon' properties of an existing object.
         *
         * 3.  Remove a station:
         * Delete the entire object for that station from the array.
         *
         * Each station object MUST have:
         * - 'name': A string for the display name of the radio station (e.g., 'The Beat 102.7').
         * - 'src': A string for the URL to the MP3 audio file for the station.
         * IMPORTANT: Replace placeholder URLs with actual paths to your MP3 files.
         * Ensure these URLs are publicly accessible.
         * Example: 'https://yourwebsite.com/audio/my-radio-station.mp3'
         * - 'icon': A string for the URL to the station's logo or icon image.
         * Replace placeholder URLs with links to your own image files.
         * For best visual results, use square images.
         * Example: 'https://yourwebsite.com/images/my-station-logo.png'
         *
         * =====================================================================
         */
        const radioStations = [
            { name: 'The Beat 102.7', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/FF5733/FFFFFF?text=Beat' },
            { name: 'The Classics 104.1', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/33FF57/000000?text=Classics' },
            { name: 'Electro-Choc Fusion FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/3357FF/FFFFFF?text=ECFFM' },
            { name: 'International Funk 99', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/F4FF33/000000?text=IF99' },
            { name: 'Independence FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'https://placehold.co/120x120/8D33FF/FFFFFF?text=Indie' },
            { name: 'Integrity 2.0', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'https://placehold.co/120x120/FF338D/000000?text=Int2.0' },
            { name: 'Jazz Nation Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/33FFB5/000000?text=JNR' },
            { name: 'The Journey', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/FF8D33/FFFFFF?text=Journey' },
            { name: 'K109 The Studio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/33A8FF/000000?text=K109' },
            { name: 'Liberty City Hardcore', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/8DFF33/000000?text=LCH' },
            { name: 'Liberty Rock Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'https://placehold.co/120x120/FF33F4/FFFFFF?text=LRR' },
            { name: 'Massive B Soundsystem', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'https://placehold.co/120x120/33FF57/000000?text=MassiveB' },
            { name: 'Public Liberty Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/5733FF/FFFFFF?text=PLR' },
            { name: 'Radio Broker', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/FF3333/FFFFFF?text=Broker' },
            { name: 'RamJam FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/33FFF4/000000?text=RamJam' },
            { name: 'San Juan Sounds', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/FFBB33/000000?text=SJS' },
            { name: 'Self-Actualization FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'https://placehold.co/120x120/338DFF/FFFFFF?text=SAFM' },
            { name: 'Tuff Gong Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'https://placehold.co/120x120/FF33BB/000000?text=TGR' },
            { name: 'The Vibe', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/33FF8D/000000?text=Vibe' },
            { name: 'Vice City FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/BB33FF/FFFFFF?text=VCFM' },
            { name: 'Vladivostok FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/33BBFF/000000?text=VFM' },
            { name: 'WKTT Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/FF3333/FFFFFF?text=WKTT' }
        ];

        // Get references to DOM elements
        const audio = document.getElementById('radio-audio');
        const currentStationNameDisplay = document.getElementById('current-station-name');
        const currentStationIconDisplay = document.getElementById('current-station-icon');
        const prevStationIconDisplay = document.getElementById('prev-station-icon');
        const nextStationIconDisplay = document.getElementById('next-station-icon');
        const prevPrevStationIconDisplay = document.getElementById('prev-prev-station-icon');
        const nextNextStationIconDisplay = document.getElementById('next-next-station-icon');
        const playPauseButton = document.getElementById('play-pause-button');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const toastMessageElement = document.getElementById('toast-message');
        const radioContainer = document.querySelector('.radio-container');

        let currentStationIndex = -1;
        let loadingStationIndex = -1;
        const audioCache = new Map(); // Stores Audio objects for efficient switching

        let toastTimeout;
        /**
         * Displays a toast message at the top of the container.
         * @param {string} message - The message to display.
         * @param {number} duration - The duration in milliseconds for which the toast is visible.
         */
        function showToast(message, duration = 2000) {
            console.log("Showing toast:", message);
            clearTimeout(toastTimeout);
            toastMessageElement.textContent = message;
            toastMessageElement.classList.add('show');
            toastTimeout = setTimeout(() => {
                toastMessageElement.classList.remove('show');
            }, duration);
        }

        /**
         * Retrieves an Audio element for a given station index from cache, or creates a new one.
         * Manages the audio cache to keep only relevant adjacent stations loaded.
         * @param {number} index - The index of the station.
         * @returns {HTMLAudioElement | null} The Audio element or null if index is out of bounds.
         */
        function getOrCreateAudioElement(index) {
            if (index < 0 || index >= radioStations.length) {
                return null;
            }

            if (audioCache.has(index)) {
                return audioCache.get(index);
            }

            const station = radioStations[index];
            const newAudio = new Audio(station.src);
            newAudio.preload = 'auto'; // Suggest to preload
            audioCache.set(index, newAudio);

            const current = currentStationIndex;
            const effectiveCurrent = current !== -1 ? current : 0;

            // Define the indices for the 5 visible carousel slots (current, 2 prev, 2 next)
            // These are the only audio elements we actively keep in cache to save memory
            const indicesToKeep = new Set([
                effectiveCurrent,
                (effectiveCurrent - 1 + radioStations.length) % radioStations.length,
                (effectiveCurrent + 1) % radioStations.length,
                (effectiveCurrent - 2 + radioStations.length) % radioStations.length,
                (effectiveCurrent + 2) % radioStations.length
            ]);

            // Clean up old cache entries that are no longer neighbors
            audioCache.forEach((cachedAudio, key) => {
                if (!indicesToKeep.has(key)) {
                    cachedAudio.pause(); // Stop any playback if it was somehow playing
                    cachedAudio.src = ''; // Clear source to release resources
                    audioCache.delete(key);
                }
            });

            return newAudio;
        }

        /**
         * Pre-loads audio for the adjacent stations (2 previous and 2 next) to enable smooth transitions.
         * @param {number} currentIndex - The index of the currently active station.
         */
        function preloadNeighbors(currentIndex) {
            if (radioStations.length < 1) return;

            // Indices to preload: prev, next, prev-prev, next-next
            const indicesToPreload = [
                (currentIndex - 1 + radioStations.length) % radioStations.length,
                (currentIndex + 1) % radioStations.length,
                (currentIndex - 2 + radioStations.length) % radioStations.length,
                (currentIndex + 2) % radioStations.length
            ];

            indicesToPreload.forEach(index => {
                const audioToPreload = getOrCreateAudioElement(index);
                // Only load if the audio element exists and hasn't already loaded enough data
                if (audioToPreload && audioToPreload.readyState < 2) { // READY_STATE_HAVE_CURRENT_DATA
                    audioToPreload.load();
                }
            });
        }

        /**
         * Updates the displayed icons in the carousel for the current, previous, and next stations.
         * Handles circular indexing for seamless looping.
         * @param {number} index - The index of the currently active station.
         */
        function updateIconCarousel(index) {
            if (radioStations.length === 0) {
                // Display generic placeholders if no stations are defined
                currentStationIconDisplay.src = "https://placehold.co/120x120/4299e1/ffffff?text=Icon";
                currentStationIconDisplay.alt = "Station Icon";
                prevStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Prev";
                nextStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Next";
                prevPrevStationIconDisplay.src = "https://placehold.co/60x60/6B7280/FFFFFF?text=P-P";
                nextNextStationIconDisplay.src = "https://placehold.co/60x60/6B7280/FFFFFF?text=N-N";
                // Ensure opacities are set correctly for initial empty state
                prevStationIconDisplay.style.opacity = '0.4';
                nextStationIconDisplay.style.opacity = '0.4';
                currentStationIconDisplay.style.opacity = '1';
                prevPrevStationIconDisplay.style.opacity = '0.15';
                nextNextStationIconDisplay.style.opacity = '0.15';
                return;
            }

            // Helper to get circular index for any given offset
            const getCircularIndex = (i) => (i + radioStations.length) % radioStations.length;

            // Use 0 for initial display if no station is active yet, otherwise use current index
            let displayIndex = index === -1 ? 0 : index;

            // Calculate indices for all 5 display slots
            let prevPrevIndex = getCircularIndex(displayIndex - 2);
            let prevIndex = getCircularIndex(displayIndex - 1);
            let nextIndex = getCircularIndex(displayIndex + 1);
            let nextNextIndex = getCircularIndex(displayIndex + 2);

            // Set sources and alt text for all five icons
            prevPrevStationIconDisplay.src = radioStations[prevPrevIndex].icon;
            prevPrevStationIconDisplay.alt = `${radioStations[prevPrevIndex].name} Icon`;

            prevStationIconDisplay.src = radioStations[prevIndex].icon;
            prevStationIconDisplay.alt = `${radioStations[prevIndex].name} Icon`;

            currentStationIconDisplay.src = radioStations[displayIndex].icon;
            currentStationIconDisplay.alt = `${radioStations[displayIndex].name} Icon`;

            nextStationIconDisplay.src = radioStations[nextIndex].icon;
            nextStationIconDisplay.alt = `${radioStations[nextIndex].name} Icon`;

            nextNextStationIconDisplay.src = radioStations[nextNextIndex].icon;
            nextNextStationIconDisplay.alt = `${radioStations[nextNextIndex].name} Icon`;
        }

        /**
         * Loads and attempts to play a specific radio station.
         * Handles loading states, error reporting, and UI updates.
         * @param {number} index - The index of the station to play.
         */
        async function playStation(index) {
            // Prevent re-playing the same station if it's already active and not paused, or if it's already loading
            if ((index === currentStationIndex && !audio.paused && loadingStationIndex === -1) || loadingStationIndex === index) {
                return;
            }

            // If a different station is currently loading, interrupt it
            if (loadingStationIndex !== -1 && loadingStationIndex !== index) {
                audio.pause();
                audio.src = ''; // Clear source to interrupt network request
                audio.load();   // Force reload to clear internal state
                // Remove any old event listeners attached directly to 'audio' to prevent stale callbacks
                audio.removeEventListener('loadedmetadata', audio._currentLoadedMetadataHandler);
                audio.removeEventListener('error', audio._currentErrorHandler);
            }

            // Validate index
            if (index < 0 || index >= radioStations.length) {
                console.error('Station index out of bounds:', index);
                showToast(`Error: Invalid station selected.`, 3000);
                currentStationNameDisplay.textContent = "Error"; // Generic error for display
                return;
            }

            const station = radioStations[index];
            if (!station) {
                console.error('Station not found at index:', index);
                showToast(`Error: Station data missing.`, 3000);
                currentStationNameDisplay.textContent = "Error"; // Generic error for display
                return;
            }

            // Set loading state and disable buttons
            loadingStationIndex = index;
            playPauseButton.disabled = true;
            prevButton.disabled = true;
            nextButton.disabled = true;

            // Immediately update UI for loading feedback
            showToast(`Loading: ${station.name}...`);
            currentStationNameDisplay.textContent = station.name; // Show new station name immediately
            updateIconCarousel(index);
            playIcon.classList.remove('hidden'); // Show play icon during loading
            pauseIcon.classList.add('hidden');

            const targetAudio = getOrCreateAudioElement(index);
            if (!targetAudio) {
                console.error("Failed to get audio element for index:", index);
                showToast(`Error: Failed to prepare station.`, 3000);
                currentStationNameDisplay.textContent = "Failed to load station";
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
                loadingStationIndex = -1;
                return;
            }

            audio.src = targetAudio.src;

            // Define event handlers for this specific loading attempt
            const handleLoadedMetadata = async () => {
                // Crucial check: Only proceed if this metadata event belongs to the *currently desired* loading station
                if (loadingStationIndex !== index) {
                    console.log(`Ignoring stale onloadedmetadata for index ${index}. Current loading index is ${loadingStationIndex}.`);
                    return;
                }

                try {
                    const duration = audio.duration;
                    if (isNaN(duration) || !isFinite(duration) || duration === 0) {
                        console.error('Invalid audio duration for station:', station.name);
                        currentStationNameDisplay.textContent = `Failed to play station`;
                        showToast(`Error: Invalid audio duration.`, 3000);
                        return;
                    }

                    const randomTime = Math.random() * duration;
                    audio.currentTime = randomTime;

                    await audio.play().catch(error => {
                        console.error('Error playing station (autoplay blocked?):', station.name, error);
                        if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                            currentStationNameDisplay.textContent = `Click Play to start!`;
                            showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                        } else {
                            currentStationNameDisplay.textContent = `Failed to play station`;
                            showToast(`Error: Could not play station.`, 3000);
                        }
                        playIcon.classList.remove('hidden');
                        pauseIcon.classList.add('hidden');
                        playPauseButton.disabled = false;
                        prevButton.disabled = false;
                        nextButton.disabled = false;
                        throw error; // Re-throw to prevent further execution of success path
                    });

                    // Only proceed if play() was successful (no error thrown)
                    currentStationNameDisplay.textContent = station.name;
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                    currentStationIndex = index;
                    showToast(`Now Playing: ${station.name}`, 2000);

                    preloadNeighbors(currentStationIndex);

                } catch (error) {
                    console.error('Unhandled error in onloadedmetadata:', error);
                } finally {
                    // Re-enable buttons and reset loading state regardless of outcome
                    playPauseButton.disabled = false;
                    prevButton.disabled = false;
                    nextButton.disabled = false;
                    loadingStationIndex = -1;
                    // Remove the specific listeners for this attempt to prevent memory leaks/stale calls
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('error', handleError);
                }
            };

            const handleError = () => {
                // Crucial check: Only proceed if this error event belongs to the *currently desired* loading station
                if (loadingStationIndex !== index) {
                    console.log(`Ignoring stale onerror for index ${index}. Current loading index is ${loadingStationIndex}.`);
                    return;
                }
                console.error('Error loading audio for station:', station.name);
                currentStationNameDisplay.textContent = `Failed to load station`;
                showToast(`Error: Failed to load station.`, 3000);
                playPauseButton.disabled = false;
                prevButton.disabled = false;
                nextButton.disabled = false;
                loadingStationIndex = -1;
                audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                audio.removeEventListener('error', handleError);
            };

            // Store the current handlers so we can remove them later
            audio._currentLoadedMetadataHandler = handleLoadedMetadata;
            audio._currentErrorHandler = handleError;

            // Attach the new, specific listeners
            audio.addEventListener('loadedmetadata', handleLoadedMetadata);
            audio.addEventListener('error', handleError);

            audio.load(); // Start loading the new audio
        }

        /**
         * Toggles the play/pause state of the current audio.
         * If no station is active, it attempts to play the first one.
         */
        async function togglePlayPause() {
            if (audio.paused) {
                // If no station has been selected yet, play the first one
                if (currentStationIndex === -1 && radioStations.length > 0) {
                    await playStation(0);
                } else if (currentStationIndex !== -1) {
                    // If a station is selected but paused, try to play/resume it
                    await audio.play().catch(error => {
                        console.error('Error resuming playback (autoplay blocked?):', radioStations[currentStationIndex].name, error);
                        if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                            currentStationNameDisplay.textContent = `Click Play to start!`;
                            showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                        } else {
                            currentStationNameDisplay.textContent = `Failed to play station`;
                            showToast(`Error: Could not resume playback.`, 3000);
                        }
                        playIcon.classList.remove('hidden');
                        pauseIcon.classList.add('hidden');
                        playPauseButton.disabled = false;
                        prevButton.disabled = false;
                        nextButton.disabled = false;
                    });
                    // Only update UI if play() was successful
                    if (!audio.paused) {
                        playIcon.classList.add('hidden');
                        pauseIcon.classList.remove('hidden');
                        showToast(`Resumed: ${radioStations[currentStationIndex].name}`, 2000);
                    }
                }
            } else {
                // If audio is playing, pause it
                audio.pause();
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                if (currentStationIndex !== -1) {
                    showToast(`Paused: ${radioStations[currentStationIndex].name}`, 2000);
                }
            }
        }

        // --- Event Listeners ---
        playPauseButton.addEventListener('click', togglePlayPause);

        prevButton.addEventListener('click', () => {
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }
            let targetIndex;
            if (currentStationIndex === -1) {
                targetIndex = radioStations.length - 1; // Go to last station if none active
            } else {
                targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
            }
            playStation(targetIndex);
        });

        nextButton.addEventListener('click', () => {
            if (radioStations.length === 0) {
                showToast("No stations available!", 2000);
                return;
            }
            let targetIndex;
            if (currentStationIndex === -1) {
                targetIndex = 0; // Go to first station if none active
            } else {
                targetIndex = (currentStationIndex + 1) % radioStations.length;
            }
            playStation(targetIndex);
        });

        // Keyboard navigation for 'Q' key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'q' || event.key === 'Q') {
                event.preventDefault(); // Prevent default browser behavior (e.g., quick find)
                if (radioStations.length === 0) {
                    showToast("No stations available to cycle!", 2000);
                    return;
                }

                let nextIndex;
                if (currentStationIndex === -1) {
                    nextIndex = 0;
                } else {
                    nextIndex = (currentStationIndex + 1) % radioStations.length;
                }
                playStation(nextIndex);
            }
        });

        // Mouse wheel navigation over the radio container
        radioContainer.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling
            if (radioStations.length === 0) {
                showToast("No stations available to cycle!", 2000);
                return;
            }

            let targetIndex;
            if (event.deltaY > 0) { // Scroll down (next station)
                if (currentStationIndex === -1) {
                    targetIndex = 0;
                } else {
                    targetIndex = (currentStationIndex + 1) % radioStations.length;
                }
            } else { // Scroll up (previous station)
                if (currentStationIndex === -1) {
                    targetIndex = radioStations.length - 1;
                } else {
                    targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
                }
            }
            playStation(targetIndex);
        });

        // Handle audio ending (loop current station)
        audio.addEventListener('ended', () => {
            if (currentStationIndex !== -1) {
                playStation(currentStationIndex); // Loop current station
            } else {
                // If somehow ended without a current station, reset UI
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                currentStationNameDisplay.textContent = "Press Play"; // More direct prompt
                updateIconCarousel(-1);
            }
        });

        // Update UI when audio is paused
        audio.addEventListener('pause', () => {
            playIcon.classList.remove('hidden');
            pauseIcon.classList.add('hidden');
        });

        // Update UI when audio starts playing
        audio.addEventListener('play', () => {
            playIcon.classList.add('hidden');
            pauseIcon.classList.remove('hidden');
        });

        // --- Initialization on Page Load ---
        window.onload = () => {
            if (radioStations.length > 0) {
                // Set the current station index to the first station for initial display
                currentStationIndex = 0;
                // Update the carousel to show the first station's icons and its neighbors
                updateIconCarousel(currentStationIndex);
                // Set the initial display text
                currentStationNameDisplay.textContent = "Press Play"; // Initial prompt

                // Set the main audio element's source to the first station's audio
                audio.src = radioStations[0].src;
                // Start loading the audio file immediately in the background
                audio.load();

                // Proactively preload audio for adjacent stations (already handled by preloadNeighbors)
                preloadNeighbors(currentStationIndex);

                // Preload ALL station icons by creating Image objects
                // This ensures all icons are fetched by the browser as soon as possible
                radioStations.forEach(station => {
                    const img = new Image();
                    img.src = station.icon;
                    // You can add img.onload or img.onerror here if you need to track icon loading status
                });

            } else {
                currentStationNameDisplay.textContent = "No stations available!";
                updateIconCarousel(-1); // Show generic placeholders if no stations are defined
            }
        };

    </script>
</body>
</html>
