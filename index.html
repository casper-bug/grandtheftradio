<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA-Style Radio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent body scroll if content slightly overflows */
        }
        .radio-container {
            background-color: #2d3748; /* Slightly lighter dark background */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            text-align: center;
            border: 2px solid #4a5568;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* For toast positioning */
        }
        .icon-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        .station-icon-faded {
            width: 80px; /* Smaller size for faded icons */
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #4a5568; /* Darker border for faded icons */
            opacity: 0.6; /* Always visible, but faded */
            margin: 0 15px;
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out; /* Reduced transition duration */
        }
        .station-icon {
            width: 120px; /* Main icon size */
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #4299e1; /* Blue border for the current icon */
            box-shadow: 0 0 15px rgba(66, 153, 225, 0.6);
            opacity: 1; /* Always visible and full opacity */
            transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out; /* Reduced transition duration */
        }
        .station-icon:hover {
            transform: scale(1.05);
        }
        .station-name-display {
            font-size: 2.5rem; /* Larger font for station name */
            font-weight: 800;
            color: #4299e1; /* Blue for active station name */
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(66, 153, 225, 0.5);
        }
        .play-pause-button {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 12px 25px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            border: none;
            outline: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .play-pause-button:hover {
            background-color: #636b77;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
        }
        .play-pause-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        /* Hidden loading spinner and volume bar styles */
        .hidden {
            display: none !important;
        }

        .hint-text {
            font-size: 0.9rem;
            color: #a0aec0;
            margin-top: 15px;
        }

        /* Toast styles */
        .toast-message {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            z-index: 1000;
            white-space: nowrap;
        }
        .toast-message.show {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>
<body class="antialiased">
    <div class="radio-container">
        <h1 class="text-3xl font-bold mb-6 text-blue-400">GTA Radio</h1>

        <div class="icon-carousel">
            <img id="prev-station-icon" src="" alt="Previous Station Icon" class="station-icon-faded">
            <img id="current-station-icon" src="" alt="Current Station Icon" class="station-icon">
            <img id="next-station-icon" src="" alt="Next Station Icon" class="station-icon-faded">
        </div>

        <div class="mb-6">
            <p class="text-lg font-semibold mb-2">Now Playing:</p>
            <p id="current-station-name" class="station-name-display">Select a Station</p>
        </div>

        <audio id="radio-audio" class="w-full mb-6 hidden" controls></audio>

        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 w-full">
            <button id="play-pause-button" class="play-pause-button flex-grow sm:flex-grow-0 px-6 py-3">
                <span id="play-pause-icon">▶️</span>
                <span class="ml-2">Play</span>
            </button>
            </div>

        <div id="toast-message" class="toast-message"></div>

        <p class="hint-text">Press 'Q' to change station</p>
    </div>

    <script>
        // Define your radio stations here.
        // IMPORTANT: Replace 'path/to/your/audio.mp3' with actual paths to your MP3 files.
        // Also, add 'icon' paths for your station logos.
        const radioStations = [
            { name: 'The Beat 102.7', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/FF5733/FFFFFF?text=Beat' },
            { name: 'The Classics 104.1', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/33FF57/000000?text=Classics' },
            { name: 'Electro-Choc Fusion FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/3357FF/FFFFFF?text=ECFFM' },
            { name: 'International Funk 99', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/F4FF33/000000?text=IF99' },
            { name: 'Independence FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'https://placehold.co/120x120/8D33FF/FFFFFF?text=Indie' },
            { name: 'Integrity 2.0', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'https://placehold.co/120x120/FF338D/000000?text=Int2.0' },
            { name: 'Jazz Nation Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/33FFB5/000000?text=JNR' },
            { name: 'The Journey', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/FF8D33/FFFFFF?text=Journey' },
            { name: 'K109 The Studio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/33A8FF/000000?text=K109' },
            { name: 'Liberty City Hardcore', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/8DFF33/000000?text=LCH' },
            { name: 'Liberty Rock Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'https://placehold.co/120x120/FF33F4/FFFFFF?text=LRR' },
            { name: 'Massive B Soundsystem', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'https://placehold.co/120x120/33FF57/000000?text=MassiveB' },
            { name: 'Public Liberty Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/5733FF/FFFFFF?text=PLR' },
            { name: 'Radio Broker', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/FF3333/FFFFFF?text=Broker' },
            { name: 'RamJam FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/33FFF4/000000?text=RamJam' },
            { name: 'San Juan Sounds', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/FFBB33/000000?text=SJS' },
            { name: 'Self-Actualization FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3', icon: 'https://placehold.co/120x120/338DFF/FFFFFF?text=SAFM' },
            { name: 'Tuff Gong Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3', icon: 'https://placehold.co/120x120/FF33BB/000000?text=TGR' },
            { name: 'The Vibe', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3', icon: 'https://placehold.co/120x120/33FF8D/000000?text=Vibe' },
            { name: 'Vice City FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3', icon: 'https://placehold.co/120x120/BB33FF/FFFFFF?text=VCFM' },
            { name: 'Vladivostok FM', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3', icon: 'https://placehold.co/120x120/33BBFF/000000?text=VFM' },
            { name: 'WKTT Radio', src: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3', icon: 'https://placehold.co/120x120/FF3333/FFFFFF?text=WKTT' }
        ];

        // Get references to DOM elements
        const audio = document.getElementById('radio-audio');
        const currentStationNameDisplay = document.getElementById('current-station-name');
        const currentStationIconDisplay = document.getElementById('current-station-icon');
        const prevStationIconDisplay = document.getElementById('prev-station-icon');
        const nextStationIconDisplay = document.getElementById('next-station-icon');
        const playPauseButton = document.getElementById('play-pause-button');
        const playPauseIcon = document.getElementById('play-pause-icon');
        // const volumeSlider = document.getElementById('volume-slider'); // Removed
        // const loadingIndicator = document.getElementById('loading-indicator'); // Removed
        const toastMessageElement = document.getElementById('toast-message');
        const radioContainer = document.querySelector('.radio-container'); // Get the radio container

        // Initialize currentStationIndex to -1 to indicate no station is playing initially
        let currentStationIndex = -1;
        // New variable to track which station is currently attempting to load
        let loadingStationIndex = -1;

        // Cache for pre-loaded audio elements
        // Stores Audio objects keyed by their station index: Map<number, HTMLAudioElement>
        const audioCache = new Map();

        /**
         * Shows a toast message.
         * @param {string} message - The message to display in the toast.
         * @param {number} duration - How long the toast should be visible in milliseconds.
         */
        let toastTimeout;
        function showToast(message, duration = 2000) {
            console.log("Showing toast:", message); // Added for debugging
            clearTimeout(toastTimeout); // Clear any existing timeout
            toastMessageElement.textContent = message;
            toastMessageElement.classList.add('show');
            toastTimeout = setTimeout(() => {
                toastMessageElement.classList.remove('show');
            }, duration);
        }

        /**
         * Gets an Audio element from cache or creates a new one.
         * Also manages cache size to only keep current, prev, and next.
         * @param {number} index - The index of the station.
         * @returns {HTMLAudioElement} The Audio element for the given station.
         */
        function getOrCreateAudioElement(index) {
            // Ensure index is valid
            if (index < 0 || index >= radioStations.length) {
                return null;
            }

            if (audioCache.has(index)) {
                return audioCache.get(index);
            }

            const station = radioStations[index];
            const newAudio = new Audio(station.src);
            newAudio.preload = 'auto'; // Suggest to preload
            // newAudio.volume = volumeSlider.value; // Removed
            audioCache.set(index, newAudio);

            // Clean up old cache entries (beyond current, prev, next)
            const current = currentStationIndex;
            // Ensure current is a valid index for calculating prev/next for cache cleanup
            const effectiveCurrent = current !== -1 ? current : 0; // Use 0 if current is -1 for initial cleanup

            const prev = (effectiveCurrent - 1 + radioStations.length) % radioStations.length;
            const next = (effectiveCurrent + 1) % radioStations.length;

            // Iterate and remove if not current, prev, or next
            audioCache.forEach((cachedAudio, key) => {
                if (key !== effectiveCurrent && key !== prev && key !== next) {
                    cachedAudio.pause(); // Stop any playback if it was somehow playing
                    cachedAudio.src = ''; // Clear source to release resources
                    audioCache.delete(key);
                }
            });

            return newAudio;
        }

        /**
         * Pre-loads the audio for the previous and next stations.
         * @param {number} currentIndex - The index of the currently active station.
         */
        function preloadNeighbors(currentIndex) {
            if (radioStations.length < 2) return; // No neighbors to preload

            const prevIndex = (currentIndex - 1 + radioStations.length) % radioStations.length;
            const nextIndex = (currentIndex + 1) % radioStations.length;

            // Get or create and load for prev and next, but don't play
            const prevAudio = getOrCreateAudioElement(prevIndex);
            if (prevAudio && prevAudio.readyState < 2) { // READY_STATE_HAVE_CURRENT_DATA
                prevAudio.load();
            }

            const nextAudio = getOrCreateAudioElement(nextIndex);
            if (nextAudio && nextAudio.readyState < 2) { // READY_STATE_HAVE_CURRENT_DATA
                nextAudio.load();
            }
        }


        /**
         * Updates the displayed icons for the current, previous, and next stations.
         * @param {number} index - The index of the currently active station.
         */
        function updateIconCarousel(index) {
            if (radioStations.length === 0) {
                currentStationIconDisplay.src = "https://placehold.co/120x120/4299e1/ffffff?text=Icon";
                currentStationIconDisplay.alt = "Station Icon";
                prevStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Prev";
                nextStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Next";
                prevStationIconDisplay.style.opacity = '0.6';
                nextStationIconDisplay.style.opacity = '0.6';
                currentStationIconDisplay.style.opacity = '1';
                return;
            }

            // If index is -1 (initial state before first play), display generic placeholders
            if (index === -1) {
                currentStationIconDisplay.src = "https://placehold.co/120x120/4299e1/ffffff?text=Icon";
                currentStationIconDisplay.alt = "Station Icon";
                prevStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Prev";
                nextStationIconDisplay.src = "https://placehold.co/80x80/6B7280/FFFFFF?text=Next";
                prevStationIconDisplay.style.opacity = '0.6';
                nextStationIconDisplay.style.opacity = '0.6';
                currentStationIconDisplay.style.opacity = '1';
            } else {
                // Calculate previous and next indices, wrapping around the array
                let prevIndex = (index - 1 + radioStations.length) % radioStations.length;
                let nextIndex = (index + 1) % radioStations.length;

                // Set sources and opacities for all three icons
                prevStationIconDisplay.src = radioStations[prevIndex].icon;
                prevStationIconDisplay.alt = `${radioStations[prevIndex].name} Icon`;
                prevStationIconDisplay.style.opacity = '0.6';

                currentStationIconDisplay.src = radioStations[index].icon;
                currentStationIconDisplay.alt = `${radioStations[index].name} Icon`;
                currentStationIconDisplay.style.opacity = '1';

                nextStationIconDisplay.src = radioStations[nextIndex].icon;
                nextStationIconDisplay.alt = `${radioStations[nextIndex].name} Icon`;
                nextStationIconDisplay.style.opacity = '0.6';
            }
        }

        /**
         * Loads and plays a specific radio station from a random point.
         * @param {number} index - The index of the station in the radioStations array.
         */
        async function playStation(index) {
            // If the same station is already playing and not paused, do nothing
            // Also, if this station is already the one being loaded, do nothing
            if (index === currentStationIndex && !audio.paused && loadingStationIndex === -1) {
                return;
            }
            if (loadingStationIndex === index) {
                // If the same station is already in the process of loading, do nothing
                return;
            }

            // If a different station is already loading, interrupt it
            if (loadingStationIndex !== -1 && loadingStationIndex !== index) {
                // Stop the previous loading process
                audio.pause();
                audio.src = ''; // Clear source to interrupt network request
                audio.load();   // Force reload to clear internal state
                // Remove any old event listeners attached directly to 'audio'
                audio.removeEventListener('loadedmetadata', audio._currentLoadedMetadataHandler);
                audio.removeEventListener('error', audio._currentErrorHandler);
            }

            // Ensure index is within bounds
            if (index < 0 || index >= radioStations.length) {
                console.error('Station index out of bounds:', index);
                return;
            }

            const station = radioStations[index];
            if (!station) {
                console.error('Station not found at index:', index);
                return;
            }

            // Mark this station as the one currently attempting to load
            loadingStationIndex = index;

            // Disable play/pause button during load
            playPauseButton.disabled = true;

            // Show toast message for loading
            showToast(`Loading: ${station.name}...`);

            // Update icons immediately
            updateIconCarousel(index);

            // Get the audio element for the new station (from cache or new)
            const targetAudio = getOrCreateAudioElement(index);
            if (!targetAudio) {
                console.error("Failed to get audio element for index:", index);
                showToast(`Failed to load ${station.name}`, 3000);
                playPauseButton.disabled = false;
                loadingStationIndex = -1; // Reset loading state
                return;
            }

            // Assign the target audio's source to the global audio element
            audio.src = targetAudio.src;
            // audio.volume = targetAudio.volume; // Removed, as volume slider is removed

            // Define the event handlers for this specific loading attempt
            const handleLoadedMetadata = async () => {
                // Crucial check: Only proceed if this metadata event belongs to the *currently desired* loading station
                if (loadingStationIndex !== index) {
                    console.log(`Ignoring stale onloadedmetadata for index ${index}. Current loading index is ${loadingStationIndex}.`);
                    return;
                }

                try {
                    const duration = audio.duration;
                    if (isNaN(duration) || !isFinite(duration) || duration === 0) {
                        console.error('Invalid audio duration for station:', station.name);
                        currentStationNameDisplay.textContent = `Error loading ${station.name}`;
                        showToast(`Error loading ${station.name}`, 3000);
                        return; // Exit without playing
                    }

                    const randomTime = Math.random() * duration;
                    audio.currentTime = randomTime;

                    await audio.play().catch(error => {
                        console.error('Error playing station (autoplay blocked?):', station.name, error);
                        if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                            currentStationNameDisplay.textContent = `Click Play to start!`;
                            showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                        } else {
                            currentStationNameDisplay.textContent = `Error playing ${station.name}`;
                            showToast(`Error: ${error.message}`, 3000);
                        }
                        playPauseIcon.textContent = '▶️';
                        playPauseButton.querySelector('span:last-child').textContent = 'Play';
                        playPauseButton.disabled = false;
                        throw error; // Re-throw to prevent further execution of success path
                    });

                    // Only proceed if play() was successful (no error thrown)
                    currentStationNameDisplay.textContent = station.name; // Update name ONLY on successful play
                    playPauseIcon.textContent = '⏸️';
                    playPauseButton.querySelector('span:last-child').textContent = 'Pause';
                    currentStationIndex = index;
                    showToast(`Now Playing: ${station.name}`, 2000);

                    preloadNeighbors(currentStationIndex);

                } catch (error) {
                    // This catch block will only execute if the re-thrown error from audio.play().catch() is caught here
                    // or if there's an error in the metadata/randomTime calculation.
                    console.error('Unhandled error in onloadedmetadata:', error);
                    // UI updates for error are already handled in the audio.play().catch()
                } finally {
                    playPauseButton.disabled = false;
                    loadingStationIndex = -1; // Reset loading state
                    // Remove the specific listeners for this attempt
                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                    audio.removeEventListener('error', handleError);
                }
            };

            const handleError = () => {
                // Crucial check: Only proceed if this error event belongs to the *currently desired* loading station
                if (loadingStationIndex !== index) {
                    console.log(`Ignoring stale onerror for index ${index}. Current loading index is ${loadingStationIndex}.`);
                    return;
                }
                console.error('Error loading audio for station:', station.name);
                currentStationNameDisplay.textContent = `Error loading ${station.name}`;
                showToast(`Error loading ${station.name}`, 3000);
                playPauseButton.disabled = false;
                loadingStationIndex = -1; // Reset loading state
                // Remove the specific listeners for this attempt
                audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
                audio.removeEventListener('error', handleError);
            };

            // Store the current handlers so we can remove them later
            audio._currentLoadedMetadataHandler = handleLoadedMetadata;
            audio._currentErrorHandler = handleError;

            // Attach the new, specific listeners
            audio.addEventListener('loadedmetadata', handleLoadedMetadata);
            audio.addEventListener('error', handleError);

            audio.load(); // Start loading the new audio
        }

        /**
         * Toggles play/pause state of the audio.
         */
        async function togglePlayPause() {
            if (audio.paused) {
                // If nothing is loaded yet, load and play the first station
                if (currentStationIndex === -1 && radioStations.length > 0) {
                    await playStation(0); // Attempt to play the first station
                } else if (currentStationIndex !== -1) {
                    // If a station is selected but paused, try to play it
                    await audio.play().catch(error => {
                        console.error('Error resuming playback (autoplay blocked?):', radioStations[currentStationIndex].name, error);
                        if (error.name === "NotAllowedError" || error.name === "NotSupportedError") {
                            currentStationNameDisplay.textContent = `Click Play to start!`;
                            showToast(`Autoplay blocked. Please click the Play button.`, 5000);
                        } else {
                            currentStationNameDisplay.textContent = `Error playing ${radioStations[currentStationIndex].name}`;
                            showToast(`Error: ${error.message}`, 3000);
                        }
                        playPauseIcon.textContent = '▶️';
                        playPauseButton.querySelector('span:last-child').textContent = 'Play';
                        playPauseButton.disabled = false;
                    });
                    // Only update UI if play() was successful
                    if (!audio.paused) {
                        playPauseIcon.textContent = '⏸️';
                        playPauseButton.querySelector('span:last-child').textContent = 'Pause';
                        showToast(`Resumed: ${radioStations[currentStationIndex].name}`, 2000);
                    }
                }
            } else {
                audio.pause();
                playPauseIcon.textContent = '▶️';
                playPauseButton.querySelector('span:last-child').textContent = 'Play';
                if (currentStationIndex !== -1) {
                    showToast(`Paused: ${radioStations[currentStationIndex].name}`, 2000);
                }
            }
        }

        // Event Listeners
        playPauseButton.addEventListener('click', togglePlayPause);

        // Removed volume slider event listener
        // volumeSlider.addEventListener('input', (event) => {
        //     audio.volume = event.target.value;
        //     audioCache.forEach(cachedAudio => {
        //         cachedAudio.volume = event.target.value;
        //     });
        // });

        // Keyboard navigation for 'Q' key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'q' || event.key === 'Q') {
                event.preventDefault(); // Prevent default browser behavior (e.g., quick find)
                if (radioStations.length === 0) {
                    showToast("No stations available to cycle!", 2000);
                    return;
                }

                let nextIndex;
                if (currentStationIndex === -1) {
                    // If no station is active, start with the first one
                    nextIndex = 0;
                } else {
                    // Cycle to the next station
                    nextIndex = (currentStationIndex + 1) % radioStations.length;
                }
                playStation(nextIndex);
            }
        });

        // Removed initial volume setting
        // audio.volume = volumeSlider.value;

        // Mouse wheel navigation
        radioContainer.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling
            if (radioStations.length === 0) {
                showToast("No stations available to cycle!", 2000);
                return;
            }

            let targetIndex;
            if (event.deltaY > 0) { // Scroll down (next station)
                if (currentStationIndex === -1) {
                    targetIndex = 0;
                } else {
                    targetIndex = (currentStationIndex + 1) % radioStations.length;
                }
            } else { // Scroll up (previous station)
                if (currentStationIndex === -1) {
                    targetIndex = radioStations.length - 1; // Go to last station
                } else {
                    targetIndex = (currentStationIndex - 1 + radioStations.length) % radioStations.length;
                }
            }
            playStation(targetIndex);
        });


        // Handle audio ending (loop or stop)
        audio.addEventListener('ended', () => {
            if (currentStationIndex !== -1) {
                playStation(currentStationIndex); // Loop current station
            } else {
                playPauseIcon.textContent = '▶️';
                playPauseButton.querySelector('span:last-child').textContent = 'Play';
                currentStationNameDisplay.textContent = "Press 'Q' or Play";
                updateIconCarousel(-1); // Reset icons to initial state
            }
        });

        // Handle audio being paused by user or system
        audio.addEventListener('pause', () => {
            playPauseIcon.textContent = '▶️';
            playPauseButton.querySelector('span:last-child').textContent = 'Play';
        });

        // Handle audio being played
        audio.addEventListener('play', () => {
            playPauseIcon.textContent = '⏸️';
            playPauseButton.querySelector('span:last-child').textContent = 'Pause';
        });

        // Initialize icons and text on page load
        window.onload = () => {
            if (radioStations.length > 0) {
                // Set the current station index to the first station
                currentStationIndex = 0;
                // Update the carousel to show the first station's icons and its neighbors
                updateIconCarousel(currentStationIndex);
                // Set the initial display text
                currentStationNameDisplay.textContent = "Press 'Q' or Play";
                // Preload neighbors of the initial station
                preloadNeighbors(currentStationIndex);
            } else {
                currentStationNameDisplay.textContent = "No stations available!";
                updateIconCarousel(-1); // Show generic placeholders if no stations are defined
            }
        };

    </script>
</body>
</html>
